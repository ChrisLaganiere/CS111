# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Chris Laganiere
Student ID: 404300154
Email: chrislaganiere@gmail.com

# Partner 2 (if you're working in a team)
Name: Juan Caesar Susilo
Student ID: 004282294
Email: juanuni95@gmail.com

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)
We used process forking to download and upload files in parallel. For every file requested for download, a new process is forked, which begins downloading the file from any available peers. When all forked download processes finish (successfully or not) and exit, uploads begin in parallel, again by forking a new process for every upload request. This is done with waitpid given the parameter WNOHANG, so that it doesn't waste CPU time while waiting for upload requests.

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)
We found that the strcpy function can unintentionally corrupt memory due to buffer overrun. This can be triggered by having an excessively long filename argument, and can result in a program crash or even a malicious buffer overflow attack by exploiting the overrun. We prevent this by making sure that no filename is longer than the allotted space, using strncpy to copy only the maximum allotted characters at most into the struct's filename.

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)
We prevented bad peers from sending excessively large files (and thus exhausting our resource). In our case, we limited the size of the file to 132072 bytes (enough for the cat pictures).
We also checked for requests for file uploads for files which do not exist or are in another directory other than /test. This would be unsecure as a malicious attacker could steal data. We do this by finding the path of files requested for upload and comparing this to make sure it contains the current working directory (and is a subdirectory).
We also check for connections which don't actually transfer any data, or do slow too slowly, as these waste resources. If files downloading from another peer do not meet a minimum transfer rate, the connection is closed.

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)

# Extra credit problems
#Extra credit problem: none

# Add any other information you'd like us to know below this line.
